
tau          :: 6.28318530717958647692528676655900576
pi           :: 3.14159265358979323846264338327950288

e            :: 2.71828182845904523536

epsilon      :: 1.19209290e-7

#library "llvm"

#foreign llvm {
    sqrt    :: (x: f64) -> f64        #linkname "llvm.sqrt.f64"

    sin     :: (x: f64) -> f64        #linkname "llvm.sin.f64"

    cos     :: (x: f64) -> f64        #linkname "llvm.cos.f64"

    pow     :: (x, power: f64) -> f64 #linkname "llvm.pow.f64"

    fmuladd :: (a, b, c: f64) -> f64  #linkname "llvm.fmuladd.f64"
}

tan  :: fn(x: f64) -> f64 { return sin(x) / cos(x) }

sign :: fn(x: f64) -> f64 {
    if x >= 0.0 return +1
    else return -1
}

identity :: fn() -> [4][4]f32 {
    return [4][4]f32 {
        {1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {0, 0, 0, 1}
    }
}

transpose :: fn(m: [4][4]f32) -> [4][4]f32 {
    for j := 0; j < 4; j += 1 {
        for i := 0; i < 4; i += 1 {
            m[i][j], m[j][i] = m[j][i], m[i][j]
        }
    }
    return m
} 

mul :: fn(a,b: [4][4]f32) -> [4][4]f32 {
    c: [4][4]f32
    for j := 0; j < 4; j += 1 {
        for i := 0; i < 4; i += 1 {
            c[j][i] = a[0][i] * b[j][0] +
                      a[1][i] * b[j][1] +
                      a[2][i] * b[j][2] +
                      a[3][i] * b[j][3]
        }
    }
    return c
}

inverse :: fn(m: [4][4]f32) -> [4][4]f32 {
    o: [4][4]f32

    sf00 := m[2][2] * m[3][3] - m[3][2] * m[2][3]
    sf01 := m[2][1] * m[3][3] - m[3][1] * m[2][3]
    sf02 := m[2][1] * m[3][2] - m[3][1] * m[2][2]
    sf03 := m[2][0] * m[3][3] - m[3][0] * m[2][3]
    sf04 := m[2][0] * m[3][2] - m[3][0] * m[2][2]
    sf05 := m[2][0] * m[3][1] - m[3][0] * m[2][1]
    sf06 := m[1][2] * m[3][3] - m[3][2] * m[1][3]
    sf07 := m[1][1] * m[3][3] - m[3][1] * m[1][3]
    sf08 := m[1][1] * m[3][2] - m[3][1] * m[1][2]
    sf09 := m[1][0] * m[3][3] - m[3][0] * m[1][3]
    sf10 := m[1][0] * m[3][2] - m[3][0] * m[1][2]
    sf11 := m[1][1] * m[3][3] - m[3][1] * m[1][3]
    sf12 := m[1][0] * m[3][1] - m[3][0] * m[1][1]
    sf13 := m[1][2] * m[2][3] - m[2][2] * m[1][3]
    sf14 := m[1][1] * m[2][3] - m[2][1] * m[1][3]
    sf15 := m[1][1] * m[2][2] - m[2][1] * m[1][2]
    sf16 := m[1][0] * m[2][3] - m[2][0] * m[1][3]
    sf17 := m[1][0] * m[2][2] - m[2][0] * m[1][2]
    sf18 := m[1][0] * m[2][1] - m[2][0] * m[1][1]

    o[0][0] = +(m[1][1] * sf00 - m[1][2] * sf01 + m[1][3] * sf02)
    o[0][1] = -(m[1][0] * sf00 - m[1][2] * sf03 + m[1][3] * sf04)
    o[0][2] = +(m[1][0] * sf01 - m[1][1] * sf03 + m[1][3] * sf05)
    o[0][3] = -(m[1][0] * sf02 - m[1][1] * sf04 + m[1][2] * sf05)
    o[1][0] = -(m[0][1] * sf00 - m[0][2] * sf01 + m[0][3] * sf02)
    o[1][1] = +(m[0][0] * sf00 - m[0][2] * sf03 + m[0][3] * sf04)
    o[1][2] = -(m[0][0] * sf01 - m[0][1] * sf03 + m[0][3] * sf05)
    o[1][3] = +(m[0][0] * sf02 - m[0][1] * sf04 + m[0][2] * sf05)
    o[2][0] = +(m[0][1] * sf06 - m[0][2] * sf07 + m[0][3] * sf08)
    o[2][1] = -(m[0][0] * sf06 - m[0][2] * sf09 + m[0][3] * sf10)
    o[2][2] = +(m[0][0] * sf11 - m[0][1] * sf09 + m[0][3] * sf12)
    o[2][3] = -(m[0][0] * sf08 - m[0][1] * sf10 + m[0][2] * sf12)
    o[3][0] = -(m[0][1] * sf13 - m[0][2] * sf14 + m[0][3] * sf15)
    o[3][1] = +(m[0][0] * sf13 - m[0][2] * sf16 + m[0][3] * sf17)
    o[3][2] = -(m[0][0] * sf14 - m[0][1] * sf16 + m[0][3] * sf18)
    o[3][3] = +(m[0][0] * sf15 - m[0][1] * sf17 + m[0][2] * sf18)

    ood := 1.0 / (m[0][0] * o[0][0] +
                  m[0][1] * o[0][1] +
                  m[0][2] * o[0][2] +
                  m[0][3] * o[0][3])

    o[0][0] *= ood
    o[0][1] *= ood
    o[0][2] *= ood
    o[0][3] *= ood
    o[1][0] *= ood
    o[1][1] *= ood
    o[1][2] *= ood
    o[1][3] *= ood
    o[2][0] *= ood
    o[2][1] *= ood
    o[2][2] *= ood
    o[2][3] *= ood
    o[3][0] *= ood
    o[3][1] *= ood
    o[3][2] *= ood
    o[3][3] *= ood

    return o
}

translate :: fn(v: [3]f32) -> [4][4]f32 {
    m := identity()
    m[3][0] = v[0]
    m[3][1] = v[1]
    m[3][2] = v[2]
    m[3][3] = 1
    return m
}

rotate :: fn(v: [3]f32, rads: f32) -> [4][4]f32 {
    // TODO: cos, sin and norm
    m := identity()
    return m
}

scale :: fn(m: [4][4]f32, s: f32) -> [4][4]f32 {
    m[0][0] *= s
    m[1][1] *= s
    m[2][2] *= s
    return m 
}

look_at :: fn(eye, centre, up: [3]f32) -> [4][4]f32 {
    // TODO: norm, cross
    return identity()
}
